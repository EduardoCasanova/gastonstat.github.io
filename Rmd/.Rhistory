# update vectors
u = v
}
iters
u
v
u = vector("list", num_blocks)
for (k in 1L:num_blocks) {
u[[k]] = normalize(rep(1, length(blocks[[k]])))
}
Z = mapply("%*%", X, u)   # Xk %*% uk
# block weights (in a list)
V = lapply(X, function(x, z) rowSums(crossprod(x, z)), Z)
V
v = lapply(X, function(x, z) rowSums(crossprod(x, z)), Z)
v = lapply(v, function(x) normalize(x))
v
rm(list =ls())
MaxBet <- function(Data, blocks = NULL, num_dim = 1)
{
# blockification
num_blocks = length(blocks)
Blocks = vector("list", num_blocks)
for (b in 1L:num_blocks) {
Blocks[[b]] = Data[,blocks[[b]]]
}
# list of vectors (loadings)
u = vector("list", num_blocks)
for (k in 1L:num_blocks) {
u[[k]] = normalize(rep(1, length(blocks[[k]])))
}
# for each dimension
for (i in 1L:num_dim)
{
# iterative procedure
iters = 1
repeat
{
# block scores (in a matrix)
Z = mapply("%*%", X, u)   # Xk %*% uk
# block weights (in a list)
v = lapply(X, function(x, z) rowSums(crossprod(x, z)), Z)
# normalized block weights (in a list)
v = lapply(v, function(x) normalize(x))
# check convergence
uv_diff = unlist(v) - unlist(u)
if (sqrt(sum(uv_diff^2)) < 0.0001) break
iters = iters + 1
# update vectors
u = v
}
}
}
n = 10000
p = 6
set.seed(5)
Data = matrix(rnorm(n*p), n, p)
blocks = list(1:2, 3:4, 5:6)
num_dim = 1
system.time(MaxBet(Data, blocks))
MaxBet <- function(Data, blocks = NULL, num_dim = 1)
{
# blockification
num_blocks = length(blocks)
X = vector("list", num_blocks)
for (b in 1L:num_blocks) {
X[[b]] = Data[,blocks[[b]]]
}
# list of vectors (loadings)
u = vector("list", num_blocks)
for (k in 1L:num_blocks) {
u[[k]] = normalize(rep(1, length(blocks[[k]])))
}
# for each dimension
for (i in 1L:num_dim)
{
# iterative procedure
iters = 1
repeat
{
# block scores (in a matrix)
Z = mapply("%*%", X, u)   # Xk %*% uk
# block weights (in a list)
v = lapply(X, function(x, z) rowSums(crossprod(x, z)), Z)
# normalized block weights (in a list)
v = lapply(v, function(x) normalize(x))
# check convergence
uv_diff = unlist(v) - unlist(u)
if (sqrt(sum(uv_diff^2)) < 0.0001) break
iters = iters + 1
# update vectors
u = v
}
}
}
n = 10000
p = 6
set.seed(5)
Data = matrix(rnorm(n*p), n, p)
blocks = list(1:2, 3:4, 5:6)
num_dim = 1
system.time(MaxBet(Data, blocks))
library(multibock)
library(mbcore)
?blockmatrix
# create a regular matrix
a = matrix(runif(20), 5, 4)
# convert 'a' into a block-matrix
A = blockmatrix(a, c(2, 3), c(2, 2))
A
describe(A)
reveal(A)
bloxks
blocks
lengths(blocks)
listify(blocks)
?listify
indexify(blocks)
n = 10
p = 6
set.seed(5)
Data = matrix(rnorm(n*p), n, p)
blocks = list(1:2, 3:4, 5:6)
num_dim = 1
# blockification
num_blocks = length(blocks)
X = vector("list", num_blocks)
for (b in 1L:num_blocks) {
X[[b]] = Data[,blocks[[b]]]
}
# list of vectors (loadings)
u = vector("list", num_blocks)
for (k in 1L:num_blocks) {
u[[k]] = normalize(rep(1, length(blocks[[k]])))
}
u
normalize
indexify(blocks)
blocks
listify(indexify(blocks))
listify(lengths(blocks))
lengths(blocks)
# let's say you have a vector of indices list like this
number_elements = c(3, 1, 5)
# get list of index vectors based on 'number_elements'
listify(number_elements)
number_elements
listify(c(2,2,2))
listify
listify(c(3, 2, 1))
listify(c(3, 2, 3))
listify(c(3, 3, 3))
mapply(rep, seq_along(c(3,3,3)), c(3,3,3))
mapply(rep, seq_along(c(3,3,3)), c(3,3,3), SIMPLIFY=FALSE)
# let's say you have a numeric vector like this
num_vec = c(2, 3, 1, 4)
# get indices in vector format
indexify(num_vec)
blockvector
?blockvector
# some vectors
vnum = runif(10)
vlog = sample(c(TRUE, FALSE), size=10, replace=TRUE)
vstr = letters[1:10]
# convert vectors into block-vectors
bnum = blockvector(vnum, 10, 1)
bnum
separate(bnum)
separate(bstr)
lapply(y, function(a, b) b[a])
blog = blockvector(vlog, c(5,5), 2)
bstr = blockvector(vstr, c(3,3,4), 3)
separate(bstr)
separate
vstr
vector_to_dummy(c(2,2,2))
vdum = vector_to_dummy(c(2,2,2))
t(vdum) %*% 1:6
vdum
1:6
1:6 * vdum
vector_to_dummy
indexify(blocks)
rm(list = ls())
n = 10
p = 6
set.seed(5)
X = matrix(rnorm(n*p), n, p)
blocks = list(1:2, 3:4, 5:6)
num_dim = 1
# blockification
num_blocks = length(blocks)
num_vars = ncol(X)
indices = indexify(blocks)
# list of vectors (loadings)
u = rep(1, num_vars)
for (k in 1L:num_blocks) {
u[[k]] = normalize(rep(1, length(blocks[[k]])))
}
v = u
XX = t(X) %*% X
1L:num_blocks
num_blocks = length(blocks)
num_vars = ncol(X)
indices = indexify(blocks)
# list of vectors (loadings)
u = rep(1, num_vars)
for (k in 1L:num_blocks) {
u[indices == k] = normalize(u[indices == k])
}
v = u
u
XX = t(X) %*% X
v = XX %*% u
v
for (k in 1L:num_blocks) {
v[indices == k] = normalize(u[indices == k])
}
v
v = XX %*% u
# normalize weights
for (k in 1L:num_blocks) {
v[indices == k] = normalize(v[indices == k])
}
v
v - u
# iterative procedure
iters = 1
repeat
{
# block scores (in a matrix)
v = as.numeric(XX %*% u)
# normalize weights
for (k in 1L:num_blocks) {
v[indices == k] = normalize(v[indices == k])
}
# check convergence
uv_diff = v - u
if (sqrt(sum(uv_diff^2)) < 0.0001) break
iters = iters + 1
# update vectors
u = v
}
iters
u
v
rm(list =ls())
maxhan <- function(X, blocks = NULL, num_dim = 1)
{
# blockification
num_blocks = length(blocks)
num_vars = ncol(X)
indices = indexify(blocks)
# list of vectors (loadings)
u = rep(1, num_vars)
for (k in 1L:num_blocks) {
u[indices == k] = normalize(u[indices == k])
}
v = u
XX = t(X) %*% X
# for each dimension
for (i in 1L:num_dim)
{
# iterative procedure
iters = 1
repeat
{
# block scores (in a matrix)
v = as.numeric(XX %*% u)
# normalize weights
for (k in 1L:num_blocks) {
v[indices == k] = normalize(v[indices == k])
}
# check convergence
uv_diff = v - u
if (sqrt(sum(uv_diff^2)) < 0.0001) break
iters = iters + 1
# update vectors
u = v
}
}
}
n = 10
p = 6
set.seed(5)
Data = matrix(rnorm(n*p), n, p)
blocks = list(1:2, 3:4, 5:6)
num_dim = 1
system.time(maxhan(Data, blocks))
maxhan <- function(X, blocks = NULL, num_dim = 1)
{
# blockification
num_blocks = length(blocks)
num_vars = ncol(X)
indices = indexify(blocks)
# list of vectors (loadings)
u = rep(1, num_vars)
for (k in 1L:num_blocks) {
u[indices == k] = normalize(u[indices == k])
}
v = u
XX = t(X) %*% X
# for each dimension
for (i in 1L:num_dim)
{
# iterative procedure
iters = 1
repeat
{
# block scores (in a matrix)
v = as.numeric(XX %*% u)
# normalize weights
for (k in 1L:num_blocks) {
v[indices == k] = normalize(v[indices == k])
}
# check convergence
uv_diff = v - u
if (sqrt(sum(uv_diff^2)) < 0.0001) break
iters = iters + 1
# update vectors
u = v
}
}
list(u, iters)
}
maxhan(Data, blocks)
MaxBet <- function(Data, blocks = NULL, num_dim = 1)
{
# blockification
num_blocks = length(blocks)
X = vector("list", num_blocks)
for (b in 1L:num_blocks) {
X[[b]] = Data[,blocks[[b]]]
}
# list of vectors (loadings)
u = vector("list", num_blocks)
for (k in 1L:num_blocks) {
u[[k]] = normalize(rep(1, length(blocks[[k]])))
}
# for each dimension
for (i in 1L:num_dim)
{
# iterative procedure
iters = 1
repeat
{
# block scores (in a matrix)
Z = mapply("%*%", X, u)   # Xk %*% uk
# block weights (in a list)
v = lapply(X, function(x, z) rowSums(crossprod(x, z)), Z)
# normalized block weights (in a list)
v = lapply(v, function(x) normalize(x))
# check convergence
uv_diff = unlist(v) - unlist(u)
if (sqrt(sum(uv_diff^2)) < 0.0001) break
iters = iters + 1
# update vectors
u = v
}
}
list(u, iters)
}
MaxBet(Data, blocks)
maxhan(Data, blocks)
cor(ropes)
ropes = rbind(
c(11.0, 77, 3.44, 8.5, 15,  9.1, 31.5),
c(10.5, 68, 3.24, 8.0, 11,  7.2, 32.1),
c(10.3, 66, 3.00, 8.4,  8,  9.2, 31.2),
c(10.2, 66, 3.25, 8.0,  8,  8.5, 31.7),
c( 9.9, 62, 3.16, 7.8,  7,  8.4, 35.5),
c( 9.7, 61, 3.15, 7.8,  8,  8.9, 31.7),
c( 9.4, 55, 4.00, 8.3,  7,  4.2, 32.0),
c( 9.4, 55, 3.28, 8.3,  7,  4.2, 32.0),
c( 8.4, 45, 2.66, 5.9,  7, 11.3, 29.5),
c( 7.7, 38, 2.78, 9.2, 12,  9.3, 36.0))
rownames(ropes) = c(
"enduro", "accelerator", "slimline", "eliminator",
"pulse", "lightning", "hyalite", "dominator",
"excellence", "icefloss")
colnames(ropes) = c(
"diameter", "weight", "price", "impact_force", "falls",
"stat_elong", "dyn_elong")
ropes
round(cor(ropes), 2)
X1 = ropes[ , 1:3]
# set (block) 2
X2 = ropes[ , 4:7]
cor(X1, X2)
round(cor(X1), 2)
# correlations of block 2
round(cor(X1), 2)
# within blocks correlations
round(cor(X1, X2), 2)
?sweep
average
set.seed(212)
Data = matrix(rnorm(15), 5, 3)
center_sweep <- function(x, row.w = rep(1, nrow(x))/nrow(x)) {
get_average <- function(v) sum(v * row.w) / sum(row.w)
average <- apply(x, 2, get_average)
sweep(df, 2, average)
}
# apply it
center_sweep(Data)
center_sweep <- function(x, row.w = rep(1, nrow(x))/nrow(x)) {
get_average <- function(v) sum(v * row.w) / sum(row.w)
average <- apply(x, 2, get_average)
sweep(x, 2, average)
}
# apply it
center_sweep(Data)
center_operator <- function(x) {
n = nrow(x)
ones = rep(1, n)
H = diag(n) - (1/n) * (ones %*% t(ones))
H %*% x
}
# apply operator
center_operator(Data)
center_scale <- function(x) {
scale(X, scale = FALSE)
}
# apply it
center_scale(Data)
center_scale <- function(x) {
scale(x, scale = FALSE)
}
# apply it
center_scale(Data)
center_apply <- function(x) {
apply(x, 2, function(y) y - mean(y))
}
# apply it
center_apply(Data)
center_sweep <- function(x, row.w = rep(1, nrow(x))/nrow(x)) {
get_average <- function(v) sum(v * row.w) / sum(row.w)
average <- apply(x, 2, get_average)
sweep(x, 2, average)
}
# apply it
center_sweep(Data)
center_colmeans <- function(x) {
xcenter = colMeans(x)
x - rep(xcenter, rep.int(nrow(x), ncol(x)))
}
# apply it
center_colmeans(Data)
center_operator <- function(x) {
n = nrow(x)
ones = rep(1, n)
H = diag(n) - (1/n) * (ones %*% t(ones))
H %*% x
}
# apply operator
center_operator(Data)
# fake data
X = matrix(runif(2000), 100, 20)
# test them
system.time(replicate(500, center_scale(X)))
system.time(replicate(500, center_apply(X)))
system.time(replicate(500, center_sweep(X)))
system.time(replicate(500, center_colmeans(X)))
system.time(replicate(500, center_matrix(X)))
system.time(replicate(500, center_scale(X)))
system.time(replicate(500, center_apply(X)))
system.time(replicate(500, center_sweep(X)))
system.time(replicate(500, center_colmeans(X)))
system.time(replicate(500, center_operator(X)))
center_me <- function(x) {
n = nrow(x)
ones = rep(1, n)
x_mean = ones %*% colMeans(x)
x - x_mean
}
# apply operator
center_me(Data)
center_me <- function(x) {
n = nrow(x)
ones = rep(1, n)
x_mean = ones %*% t(colMeans(x))
x - x_mean
}
# apply operator
center_me(Data)
system.time(replicate(500, center_me(X)))
center_mean <- function(x) {
ones = rep(1, nrow(x))
x_mean = ones %*% t(colMeans(x))
x - x_mean
}
# apply it
center_mean(Data)
system.time(replicate(500, center_scale(X)))
system.time(replicate(500, center_apply(X)))
system.time(replicate(500, center_sweep(X)))
system.time(replicate(500, center_colmeans(X)))
system.time(replicate(500, center_operator(X)))
system.time(replicate(500, center_mean(X)))
rm(list =ls())
KnitPost <- function(input, base.url = "/") {
require(knitr)
opts_knit$set(base.url = base.url)
fig.path <- paste0("figs/", sub(".Rmd$", "", basename(input)), "/")
opts_chunk$set(fig.path = fig.path)
opts_chunk$set(fig.cap = "center")
render_jekyll()
knit(input, envir = parent.frame())
}
setwd("/Users/Gaston/Documents/gastonstat.github.io/Rmd")
KnitPost("2014-01-15-Center-data-in-R.Rmd")
KnitPost("2014-01-15-Center-data-in-R.Rmd")
